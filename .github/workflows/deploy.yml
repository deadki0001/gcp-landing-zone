# ============================================================================
# GCP WORKLOADS DEPLOYMENT PIPELINE
# ============================================================================
# Two-stage pipeline with manual approval gate:
#   Stage 1: Plan  — runs automatically on every push to main
#   Stage 2: Apply — waits for manual approval before touching GCP
#
# Authentication: Workload Identity Federation — no credentials stored
# The gcp-workloads repo is bound to terraform-sa via bootstrap WIF binding

name: Deploy Workloads

on:
  push:
    branches:
      - main

env:
  PROJECT_ID: prod-workloads-lz-001
  REGION: europe-west1
  CLUSTER_NAME: workloads-gke-001
  WORKLOAD_IDENTITY_PROVIDER: projects/648099970996/locations/global/workloadIdentityPools/github-pool/providers/github-provider
  SERVICE_ACCOUNT: terraform-sa@project-5a757d72-eb26-477c-bd9.iam.gserviceaccount.com

jobs:
  # ============================================================================
  # JOB 1: TERRAFORM PLAN
  # Runs automatically on every push.
  # Shows what will be created — no resources are modified here.
  # ============================================================================
  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0

      # Auto-fix formatting rather than failing on it
      - name: Terraform Format
        working-directory: terraform
        run: terraform fmt -recursive

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -no-color \
            -out=tfplan
        env:
          TF_VAR_billing_account: ${{ secrets.TF_BILLING_ACCOUNT }}

      # Cluster does not exist yet on first run so this step is expected
      # to fail gracefully. continue-on-error prevents it failing the job.
      - name: Get GKE Credentials
        run: |
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} \
            --region ${{ env.REGION }} \
            --project ${{ env.PROJECT_ID }}
        continue-on-error: true

      # Only meaningful after first deployment — shows diff against live cluster
      - name: Kubectl Diff
        run: kubectl diff -f kubernetes/ || true
        continue-on-error: true

  # ============================================================================
  # JOB 2: TERRAFORM APPLY + KUBECTL APPLY
  # Waits for manual approval via GitHub environment protection.
  # Go to Settings → Environments → production → add yourself as required reviewer
  # Nothing deploys until you click approve in the GitHub Actions UI
  # ============================================================================
  apply:
    name: Terraform Apply + Kubectl Apply
    runs-on: ubuntu-latest
    needs: plan
    environment: production

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.SERVICE_ACCOUNT }}

      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.0

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      # Creates GKE cluster (~10min), Cloud SQL (~8min), networking resources
      - name: Terraform Apply
        working-directory: terraform
        run: |
          terraform apply \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -auto-approve
        env:
          TF_VAR_billing_account: ${{ secrets.TF_BILLING_ACCOUNT }}

      # Configure kubectl after cluster exists
      - name: Get GKE Credentials
        run: |
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} \
            --region ${{ env.REGION }} \
            --project ${{ env.PROJECT_ID }}

      # Idempotent secret creation — safe to run on every deployment
      - name: Create Database Secret
        run: |
          kubectl create secret generic db-credentials \
            --from-literal=password=${{ secrets.DB_PASSWORD }} \
            --dry-run=client -o yaml | kubectl apply -f -

      # Apply in strict dependency order
      - name: Apply Kubernetes Service Account
        run: kubectl apply -f kubernetes/api/serviceaccount.yaml

      - name: Apply ConfigMaps
        run: |
          kubectl apply -f kubernetes/frontend/configmap.yaml
          kubectl apply -f kubernetes/api/configmap.yaml

      - name: Apply Frontend Manifests
        run: kubectl apply -f kubernetes/frontend/

      - name: Apply API Manifests
        run: kubectl apply -f kubernetes/api/

      # Block pipeline until pods are healthy
      - name: Wait for Frontend Rollout
        run: kubectl rollout status deployment/frontend --timeout=300s

      - name: Wait for API Rollout
        run: kubectl rollout status deployment/api --timeout=300s

      # Print full cluster status and public IP at end of deployment
      - name: Print Deployment Status
        run: |
          echo "=============================="
          echo "NODES"
          echo "=============================="
          kubectl get nodes

          echo ""
          echo "=============================="
          echo "PODS"
          echo "=============================="
          kubectl get pods -o wide

          echo ""
          echo "=============================="
          echo "SERVICES"
          echo "=============================="
          kubectl get services

          echo ""
          echo "=============================="
          echo "FRONTEND PUBLIC IP"
          echo "=============================="
          kubectl get service frontend-service \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}'